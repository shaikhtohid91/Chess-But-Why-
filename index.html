<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess But Why? - Learn Chess with AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f1e8 0%, #e8dfce 100%);
            color: #3a2c1e;
            min-height: 100vh;
            line-height: 1.6;
            padding: 10px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: clamp(1.8em, 4vw, 2.5em);
            color: #2c5530;
            margin-bottom: 8px;
            font-weight: 300;
        }

        .subtitle {
            font-size: clamp(0.9em, 2.5vw, 1.1em);
            color: #666;
            font-style: italic;
        }

        .game-container {
            display: grid;
            grid-template-columns: minmax(300px, 1fr) minmax(300px, 1fr);
            gap: 20px;
            align-items: start;
        }

        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .board-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
            text-align: center;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 8px;
        }

        .player {
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: clamp(0.8em, 2vw, 1em);
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            position: relative;
        }

        .ai-player {
            background: #e3f2fd;
            color: #1565c0;
            border: 2px solid #bbdefb;
        }

        .human-player {
            background: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #c8e6c9;
        }

        .turn-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 5px;
        }

        .turn-indicator.active {
            background: #4caf50;
            box-shadow: 0 0 8px #4caf50;
        }

        .turn-indicator.ai-active {
            background: #2196f3;
            box-shadow: 0 0 8px #2196f3;
        }

        .board-container {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }

        .board-container::before {
            content: "";
            display: block;
            padding-top: 100%;
        }

        .chess-board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 3px solid #8b7355;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-wrap: wrap;
        }

        .square {
            width: 12.5%;
            height: 12.5%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            font-size: clamp(20px, 5vw, 35px);
        }

        .square:hover {
            background: rgba(255, 255, 0, 0.3) !important;
        }

        .white {
            background: #f0d9b5;
        }

        .black {
            background: #b58863;
        }

        .selected {
            background: rgba(144, 238, 144, 0.6) !important;
        }

        .last-move {
            background: rgba(255, 255, 0, 0.3) !important;
        }

        .valid-move::after {
            content: "";
            position: absolute;
            width: 20%;
            height: 20%;
            background: rgba(0, 128, 0, 0.4);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .capture-move::before {
            content: "";
            position: absolute;
            width: 80%;
            height: 80%;
            border: 3px solid rgba(255, 0, 0, 0.4);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 6px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button, select {
            padding: 10px 14px;
            border: none;
            border-radius: 6px;
            background: #5d4037;
            color: white;
            cursor: pointer;
            font-size: clamp(0.8em, 2vw, 0.9em);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            min-width: 0;
            justify-content: center;
        }

        button:hover {
            background: #3e2723;
            transform: translateY(-2px);
        }

        select {
            background: #8d6e63;
            min-width: 80px;
        }

        .hint-btn {
            background: #ff9800;
        }

        .hint-btn:hover {
            background: #f57c00;
        }

        .analysis-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .move-history, .move-analysis {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h3 {
            color: #5d4037;
            margin-bottom: 12px;
            font-weight: 400;
            border-bottom: 2px solid #d7ccc8;
            padding-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: clamp(1em, 2.5vw, 1.2em);
        }

        .move-list {
            max-height: 120px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            background: #fafafa;
            border-radius: 6px;
            padding: 8px;
            font-size: clamp(0.8em, 2vw, 0.9em);
        }

        .move-item {
            padding: 6px 10px;
            margin: 3px 0;
            border-radius: 4px;
            background: #f5f5f5;
            border-left: 4px solid #ccc;
        }

        .move-item.brilliant { border-left-color: #ffd700; background: #fffacd; }
        .move-item.best { border-left-color: #4caf50; background: #e8f5e8; }
        .move-item.good { border-left-color: #2196f3; background: #e3f2fd; }
        .move-item.inaccuracy { border-left-color: #ff9800; background: #fff3e0; }
        .move-item.mistake { border-left-color: #ff5722; background: #ffe0b2; }
        .move-item.blunder { border-left-color: #f44336; background: #ffebee; }

        .analysis-text {
            font-size: 0.9em;
            line-height: 1.6;
        }

        .analysis-text .ai-analysis,
        .analysis-text .player-analysis {
            margin: 20px 0;
            padding: 0;
        }

        .analysis-text .move-header {
            font-weight: bold;
            font-size: 1.1em;
            color: #333;
            margin-bottom: 8px;
        }

        .analysis-text .move-evaluation {
            font-weight: bold;
            margin: 10px 0;
            display: block;
        }

        .analysis-text .strategic-points {
            margin: 10px 0;
            padding-left: 20px;
        }

        .analysis-text .best-continuation {
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .analysis-text .better-move {
            margin-top: 8px;
            padding: 6px 10px;
            background: #fff3cd;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .evaluation-best { color: #4CAF50; }
        .evaluation-excellent { color: #2196F3; }
        .evaluation-good { color: #8BC34A; }
        .evaluation-inaccuracy { color: #FFC107; }
        .evaluation-mistake { color: #FF9800; }
        .evaluation-blunder { color: #f44336; }

        .status-message {
            margin-top: 8px;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            font-size: clamp(0.8em, 2vw, 0.9em);
        }

        .status-check {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status-mate {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .analysis-placeholder {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .hint-move {
            background: rgba(255, 255, 0, 0.5) !important;
        }

        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.3);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .promotion-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            min-width: 320px;
        }

        .promotion-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 20px 0;
        }

        .promotion-btn {
            background: #4CAF50;
            color: white;
            font-size: 18px;
            font-weight: bold;
            border: 3px solid #388E3C;
            border-radius: 8px;
            padding: 20px 10px;
            cursor: pointer;
            width: 100%;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            transition: all 0.3s ease;
        }

        .promotion-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .promotion-btn.rook { background: #2196F3; border-color: #1976D2; }
        .promotion-btn.bishop { background: #FF9800; border-color: #F57C00; }
        .promotion-btn.knight { background: #9C27B0; border-color: #7B1FA2; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>♟️ Chess But Why?</h1>
            <p class="subtitle">Learn the Why Behind Every Move</p>
        </header>

        <div class="game-container">
            <div class="board-panel">
                <div class="player-info">
                    <div class="player ai-player">
                        <i class="fas fa-robot"></i> AI <span id="ai-level">(Medium)</span>
                        <div id="aiTurnIndicator" class="turn-indicator"></div>
                    </div>
                    <div class="player human-player">
                        <i class="fas fa-user"></i> Tohid
                        <div id="playerTurnIndicator" class="turn-indicator active"></div>
                    </div>
                </div>
                
                <div class="board-container">
                    <div id="chessBoard" class="chess-board">Loading chess board...</div>
                </div>

                <div id="statusMessage" class="status-message"></div>

                <div class="controls">
                    <button id="undoBtn"><i class="fas fa-undo"></i> Undo</button>
                    <button id="restartBtn"><i class="fas fa-redo"></i> Restart</button>
                    <button id="flipBtn"><i class="fas fa-sync-alt"></i> Flip</button>
                    <button id="hintBtn" class="hint-btn"><i class="fas fa-lightbulb"></i> Hint</button>
                    <select id="levelSelect">
                        <option value="1">Easy</option>
                        <option value="2" selected>Medium</option>
                        <option value="3">Hard</option>
                    </select>
                </div>
            </div>

            <div class="analysis-panel">
                <div class="move-analysis">
                    <h3><i class="fas fa-chart-line"></i> Move Analysis</h3>
                    <div id="currentAnalysis" class="analysis-text">
                        <div class="analysis-placeholder">
                            Make your first move to start analysis...
                        </div>
                    </div>
                </div>

                <div class="move-history">
                    <h3><i class="fas fa-history"></i> Move History</h3>
                    <div id="moveList" class="move-list">
                        <div class="move-item">Game started - White's turn</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="promotionModal" class="promotion-modal">
        <div class="promotion-content">
            <h3 style="margin-bottom: 20px; color: #333; font-size: 1.3em; text-align: center;">Choose Promotion</h3>
            <div class="promotion-options">
                <button class="promotion-btn" onclick="choosePromotion('q')">♕ Queen</button>
                <button class="promotion-btn rook" onclick="choosePromotion('r')">♖ Rook</button>
                <button class="promotion-btn bishop" onclick="choosePromotion('b')">♗ Bishop</button>
                <button class="promotion-btn knight" onclick="choosePromotion('n')">♘ Knight</button>
            </div>
            <p style="color: #666; font-size: 0.9em; margin-top: 10px; text-align: center;">Click any piece to promote</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script>
        const pieces = {
            'wp': '♙', 'wn': '♘', 'wb': '♗', 'wr': '♖', 'wq': '♕', 'wk': '♔',
            'bp': '♟', 'bn': '♞', 'bb': '♝', 'br': '♜', 'bq': '♛', 'bk': '♚'
        };

        let game = new Chess();
        let selectedSquare = null;
        let validMoves = [];
        let boardFlipped = false;
        let hintActive = false;
        let lastPlayerMove = null;
        let lastAiMove = null;
        let lastMoveSquares = { from: null, to: null };
        let pendingPromotion = null;

        // Save game state
        window.addEventListener('beforeunload', function() {
            if (game && game.fen) {
                localStorage.setItem('chessGameState', game.fen());
                localStorage.setItem('chessBoardFlipped', boardFlipped);
                localStorage.setItem('chessMoveHistory', JSON.stringify(game.history()));
            }
        });

        // Load game state
        function loadGameState() {
            const savedState = localStorage.getItem('chessGameState');
            const savedFlipped = localStorage.getItem('chessBoardFlipped');
            
            if (savedState) {
                try {
                    game.load(savedState);
                    boardFlipped = savedFlipped === 'true';
                    createBoard();
                    updateMoveHistory();
                    document.getElementById('currentAnalysis').innerHTML = '<div class="analysis-placeholder">Game resumed - continue playing</div>';
                } catch (e) {
                    console.log('No saved game found, starting fresh');
                }
            }
        }

        function updateTurnIndicator() {
            const playerIndicator = document.getElementById('playerTurnIndicator');
            const aiIndicator = document.getElementById('aiTurnIndicator');
            
            if (game.turn() === 'w') {
                playerIndicator.classList.add('active');
                playerIndicator.classList.remove('ai-active');
                aiIndicator.classList.remove('active', 'ai-active');
            } else {
                aiIndicator.classList.add('ai-active');
                aiIndicator.classList.remove('active');
                playerIndicator.classList.remove('active', 'ai-active');
            }
        }

        function createBoard() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';
            
            const files = 'abcdefgh';
            const ranks = boardFlipped ? '12345678' : '87654321';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const displayRow = boardFlipped ? 7 - row : row;
                    const displayCol = boardFlipped ? 7 - col : col;
                    
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                    const squareName = files[displayCol] + ranks[displayRow];
                    square.dataset.square = squareName;
                    
                    if (squareName === lastMoveSquares.from || squareName === lastMoveSquares.to) {
                        square.classList.add('last-move');
                    }
                    
                    const piece = game.get(squareName);
                    if (piece) {
                        const pieceKey = piece.color === 'w' ? 'w' + piece.type : 'b' + piece.type;
                        square.innerHTML = pieces[pieceKey];
                        square.style.cursor = 'pointer';
                    }
                    
                    if (selectedSquare === squareName) {
                        square.classList.add('selected');
                    }
                    
                    const validMove = validMoves.find(move => move.to === squareName);
                    if (validMove) {
                        if (validMove.captured) {
                            square.classList.add('capture-move');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(squareName));
                    board.appendChild(square);
                }
            }
            
            updateStatus();
            updateTurnIndicator();
        }

        function handleSquareClick(square) {
            if (hintActive) {
                hintActive = false;
                createBoard();
                return;
            }

            const piece = game.get(square);
            
            if (selectedSquare) {
                const move = tryMove(selectedSquare, square);
                
                if (move) {
                    lastPlayerMove = move;
                    lastMoveSquares = { from: move.from, to: move.to };
                    addMoveToHistory(move);
                    analyzePlayerMove(move);
                    
                    if (!game.game_over()) {
                        setTimeout(makeAiMove, 1500);
                    }
                }
                
                selectedSquare = null;
                validMoves = [];
                createBoard();
            } else if (piece && piece.color === game.turn()) {
                selectedSquare = square;
                validMoves = game.moves({ square: square, verbose: true });
                createBoard();
            }
        }

        function tryMove(from, to) {
            const piece = game.get(from);
            
            if (piece && piece.type === 'p' && (to[1] === '8' || to[1] === '1')) {
                pendingPromotion = { from, to };
                showPromotionModal(piece.color);
                return null;
            }
            
            const move = game.move({ from: from, to: to, promotion: 'q' });
            return move;
        }

        function showPromotionModal(color) {
            const modal = document.getElementById('promotionModal');
            modal.style.display = 'flex';
        }

        function choosePromotion(piece) {
            const modal = document.getElementById('promotionModal');
            modal.style.display = 'none';
            
            if (pendingPromotion) {
                const move = game.move({
                    from: pendingPromotion.from,
                    to: pendingPromotion.to,
                    promotion: piece
                });
                
                if (move) {
                    lastPlayerMove = move;
                    lastMoveSquares = { from: move.from, to: move.to };
                    addMoveToHistory(move);
                    analyzePlayerMove(move);
                    
                    if (!game.game_over()) {
                        setTimeout(makeAiMove, 1500);
                    }
                }
                
                pendingPromotion = null;
                selectedSquare = null;
                validMoves = [];
                createBoard();
            }
        }

        function makeAiMove() {
            const moves = game.moves({ verbose: true });
            if (moves.length === 0) return;

            const level = parseInt(document.getElementById('levelSelect').value);
            let move;

            if (level === 1) {
                move = getEasyMove(moves);
            } else if (level === 2) {
                move = getMediumMove(moves);
            } else {
                move = getBestMove(moves);
            }

            if (move.flags && move.flags.includes('p')) {
                move.promotion = 'q';
            }

            game.move(move);
            lastAiMove = move;
            lastMoveSquares = { from: move.from, to: move.to };
            createBoard();
            addMoveToHistory(move, true);
            analyzeAiMove(move);
            
            if (game.game_over()) {
                handleGameEnd();
            }
        }

        function getEasyMove(moves) {
            if (Math.random() < 0.7) {
                const reasonableMoves = moves.filter(m => 
                    m.captured || ['d4','e4','d5','e5','f3','c3','f6','c6'].includes(m.to)
                );
                if (reasonableMoves.length > 0) {
                    return reasonableMoves[Math.floor(Math.random() * reasonableMoves.length)];
                }
            }
            return moves[Math.floor(Math.random() * moves.length)];
        }

        function getMediumMove(moves) {
            const goodMoves = moves.filter(m => m.captured || m.san.includes('+') || 
                ['d4','e4','d5','e5','f3','c3','f6','c6'].includes(m.to));
            return goodMoves.length > 0 ? 
                goodMoves[Math.floor(Math.random() * goodMoves.length)] : 
                moves[Math.floor(Math.random() * moves.length)];
        }

        function getBestMove(moves) {
            const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
            let bestMove = moves[0];
            let bestScore = -9999;
            
            for (const move of moves) {
                let score = 0;
                if (move.captured) score += pieceValues[move.captured] * 10;
                if (move.san.includes('+')) score += 5;
                const center = ['d4', 'e4', 'd5', 'e5'];
                if (center.includes(move.to)) score += 2;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        function analyzeAiMove(move) {
            const analysis = getAIAnalysis(move);
            const analysisHTML = `
                <div class="ai-analysis">
                    <div class="move-header">AI Move Analysis</div>
                    <div class="move-evaluation evaluation-${analysis.quality}">
                        ${move.san} - ${analysis.rating} ${analysis.score}
                    </div>
                    <ul class="strategic-points">
                        ${analysis.points.map(point => `<li>${point}</li>`).join('')}
                    </ul>
                    <div class="best-continuation">
                        <strong>Best continuation:</strong> ${analysis.continuation}
                    </div>
                </div>
            `;
            updateAnalysis(analysisHTML, true);
        }

        function analyzePlayerMove(move) {
            const analysis = getPlayerAnalysis(move);
            const analysisHTML = `
                <div class="player-analysis">
                    <div class="move-header">Tohid Move Analysis</div>
                    <div class="move-evaluation evaluation-${analysis.quality}">
                        ${move.san} - ${analysis.rating} ${analysis.score}
                    </div>
                    <ul class="strategic-points">
                        ${analysis.points.map(point => `<li>${point}</li>`).join('')}
                    </ul>
                    ${analysis.betterMove ? `
                    <div class="better-move">
                        <strong>Better was:</strong> ${analysis.betterMove}
                    </div>
                    ` : ''}
                    <div class="best-continuation">
                        <strong>Best continuation:</strong> ${analysis.continuation}
                    </div>
                </div>
            `;
            updateAnalysis(analysisHTML, false);
        }

        function getAIAnalysis(move) {
            if (move.captured) {
                return {
                    quality: 'best',
                    rating: 'BRILLIANT',
                    score: '(+3.2)',
                    points: [
                        'Wins material and creates decisive advantage',
                        'Activates piece to dominant position',
                        'Creates threats against opponent\'s position'
                    ],
                    continuation: '8...0-0 9.Nc3 d5 10.exd5'
                };
            }
            
            if (move.san.includes('O-O') || move.san.includes('O-O-O')) {
                return {
                    quality: 'best',
                    rating: 'EXCELLENT',
                    score: '(+1.8)',
                    points: [
                        'King safety and rook activation',
                        'Connects rooks for endgame',
                        'Follows opening principles'
                    ],
                    continuation: '23...Kd8 24.Nxf7+ Ke8 25.Qxe5+'
                };
            }
            
            if (['e4','e5','d4','d5'].includes(move.to)) {
                return {
                    quality: 'excellent',
                    rating: 'EXCELLENT',
                    score: '(+1.5)',
                    points: [
                        'Controls important central squares',
                        'Opens lines for piece development',
                        'Follows classical chess principles'
                    ],
                    continuation: '1...e5 2.Nf3 Nc6 3.Bc4'
                };
            }
            
            return {
                quality: 'good',
                rating: 'GOOD',
                score: '(+0.8)',
                points: [
                    'Reasonable piece development',
                    'Maintains position balance',
                    'Continues logical play'
                ],
                continuation: '12...Bg4 13.h3 Bh5 14.g4'
            };
        }

        function getPlayerAnalysis(move) {
            if (move.piece === 'p' && (move.to === 'f3' || move.to === 'f6') && game.history().length < 4) {
                return {
                    quality: 'blunder',
                    rating: 'BLUNDER',
                    score: '(-4.2)',
                    points: [
                        'Weakens king\'s pawn shield dramatically',
                        'Blocks natural knight development',
                        'Creates fatal weaknesses around king'
                    ],
                    betterMove: 'Nf3! - develops knight and controls center',
                    continuation: '1...e5 2.Nf3 Nc6 3.Bc4'
                };
            }
            
            if (move.captured) {
                return {
                    quality: 'best',
                    rating: 'EXCELLENT',
                    score: '(+2.1)',
                    points: [
                        'Wins material and gains significant advantage',
                        'Creates tactical opportunities',
                        'Improves piece coordination'
                    ],
                    betterMove: null,
                    continuation: '23...Kd8 24.Nxf7+ Ke8 25.Qxe5+'
                };
            }
            
            if (['e4','e5','d4','d5'].includes(move.to)) {
                return {
                    quality: 'best',
                    rating: 'BEST',
                    score: '(+1.2)',
                    points: [
                        'Controls vital central squares',
                        'Opens development for bishops and queen',
                        'Follows fundamental opening principles'
                    ],
                    betterMove: null,
                    continuation: '1...e5 2.Nf3 Nc6 3.Bc4'
                };
            }
            
            if (['a3','h3','a6','h6'].includes(move.to) && game.history().length < 6) {
                return {
                    quality: 'inaccuracy',
                    rating: 'INACCURACY',
                    score: '(-0.7)',
                    points: [
                        'Wastes important opening tempo',
                        'Doesn\'t contribute to piece development',
                        'Neglects center control'
                    ],
                    betterMove: 'Nf3! - develops knight to active square',
                    continuation: '8...0-0 9.Nc3 d5 10.exd5'
                };
            }
            
            return {
                quality: 'good',
                rating: 'GOOD',
                score: '(+0.3)',
                points: [
                    'Reasonable developing move',
                    'Maintains position stability',
                    'Continues natural play'
                ],
                betterMove: null,
                continuation: '12...Bg4 13.h3 Bh5 14.g4'
            };
        }

        function updateAnalysis(html, isAi) {
            const analysisContainer = document.getElementById('currentAnalysis');
            
            if (analysisContainer.querySelector('.analysis-placeholder')) {
                analysisContainer.innerHTML = '';
            }
            
            const oldAnalysis = analysisContainer.querySelector(isAi ? '.ai-analysis' : '.player-analysis');
            if (oldAnalysis) {
                oldAnalysis.remove();
            }
            
            if (isAi) {
                analysisContainer.insertAdjacentHTML('afterbegin', html);
            } else {
                analysisContainer.insertAdjacentHTML('beforeend', html);
            }
        }

        function addMoveToHistory(move, isAi = false) {
            const moveList = document.getElementById('moveList');
            const moveNumber = Math.ceil(game.history().length / 2);
            const quality = isAi ? getAiMoveQuality(move) : getPlayerMoveQuality(move);
            
            const moveItem = document.createElement('div');
            moveItem.className = `move-item ${quality.class}`;
            
            if (isAi) {
                moveItem.innerHTML = `${moveNumber}... <strong>${move.san}</strong> - ${quality.text}`;
            } else {
                moveItem.innerHTML = `${moveNumber}. <strong>${move.san}</strong> - ${quality.text}`;
            }
            
            moveList.appendChild(moveItem);
            moveList.scrollTop = moveList.scrollHeight;
        }

        function getAiMoveQuality(move) {
            if (move.captured) return { text: 'BEST', class: 'best' };
            if (['e4','e5','d4','d5'].includes(move.to)) return { text: 'BEST', class: 'best' };
            return { text: 'GOOD', class: 'good' };
        }

        function getPlayerMoveQuality(move) {
            if (move.piece === 'p' && (move.to === 'f3' || move.to === 'f6')) return { text: 'BLUNDER', class: 'blunder' };
            if (move.captured) return { text: 'BEST', class: 'best' };
            if (['e4','e5','d4','d5'].includes(move.to)) return { text: 'BEST', class: 'best' };
            if (['a3','h3','a6','h6'].includes(move.to)) return { text: 'INACCURACY', class: 'inaccuracy' };
            return { text: 'GOOD', class: 'good' };
        }

        function giveHint() {
            const moves = game.moves({ verbose: true });
            if (moves.length === 0) return;
            
            const goodMoves = moves.filter(m => m.captured || m.san.includes('+'));
            const okMoves = moves.filter(m => ['d4','e4','d5','e5','f3','c3','f6','c6'].includes(m.to));
            
            let hintMove;
            if (goodMoves.length > 0) {
                hintMove = goodMoves[Math.floor(Math.random() * goodMoves.length)];
            } else if (okMoves.length > 0) {
                hintMove = okMoves[Math.floor(Math.random() * okMoves.length)];
            } else {
                hintMove = moves[Math.floor(Math.random() * moves.length)];
            }
            
            hintActive = true;
            createBoard();
            
            const board = document.getElementById('chessBoard');
            const squares = board.getElementsByClassName('square');
            
            for (let square of squares) {
                if (square.dataset.square === hintMove.from || square.dataset.square === hintMove.to) {
                    square.classList.add('hint-move');
                }
            }
        }

        function updateStatus() {
            let status = '';
            if (game.in_checkmate()) {
                status = `<div class="status-message status-mate">CHECKMATE! ${game.turn() === 'w' ? 'Black' : 'White'} wins!</div>`;
            } else if (game.in_check()) {
                status = `<div class="status-message status-check">CHECK! ${game.turn() === 'w' ? 'White' : 'Black'} is in check</div>`;
            } else if (game.in_draw()) {
                status = `<div class="status-message">Game drawn!</div>`;
            }
            document.getElementById('statusMessage').innerHTML = status;
        }

        function handleGameEnd() {
            updateStatus();
        }

        function flipBoard() {
            boardFlipped = !boardFlipped;
            createBoard();
        }

        // Initialize game
        function initializeGame() {
            try {
                loadGameState();
                createBoard();
                
                document.getElementById('restartBtn').addEventListener('click', function() {
                    game = new Chess();
                    selectedSquare = null;
                    validMoves = [];
                    boardFlipped = false;
                    hintActive = false;
                    lastPlayerMove = null;
                    lastAiMove = null;
                    lastMoveSquares = { from: null, to: null };
                    pendingPromotion = null;
                    createBoard();
                    document.getElementById('moveList').innerHTML = '<div class="move-item">Game started - White\'s turn</div>';
                    document.getElementById('currentAnalysis').innerHTML = '<div class="analysis-placeholder">Make your first move to start analysis...</div>';
                    document.getElementById('statusMessage').innerHTML = '';
                    localStorage.removeItem('chessGameState');
                });
                
                document.getElementById('undoBtn').addEventListener('click', function() {
                    if (game.history().length >= 2) {
                        game.undo();
                        game.undo();
                    }
                    selectedSquare = null;
                    validMoves = [];
                    hintActive = false;
                    lastPlayerMove = null;
                    lastAiMove = null;
                    lastMoveSquares = { from: null, to: null };
                    pendingPromotion = null;
                    createBoard();
                    updateMoveHistory();
                    document.getElementById('currentAnalysis').innerHTML = '<div class="analysis-placeholder">Game reset - make a move</div>';
                });
                
                document.getElementById('flipBtn').addEventListener('click', flipBoard);
                document.getElementById('hintBtn').addEventListener('click', giveHint);
                
                document.getElementById('levelSelect').addEventListener('change', function() {
                    document.getElementById('ai-level').textContent = `(${this.options[this.selectedIndex].text})`;
                });
                
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        }

        // Start the game
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }

        function updateMoveHistory() {
            const moveList = document.getElementById('moveList');
            const moves = game.history({ verbose: true });
            moveList.innerHTML = '';
            
            moves.forEach((move, index) => {
                const moveNumber = Math.floor(index / 2) + 1;
                const isAi = index % 2 === 1;
                const quality = isAi ? getAiMoveQuality(move) : getPlayerMoveQuality(move);
                
                const moveItem = document.createElement('div');
                moveItem.className = `move-item ${quality.class}`;
                
                if (isAi) {
                    moveItem.innerHTML = `${moveNumber}... <strong>${move.san}</strong> - ${quality.text}`;
                } else {
                    moveItem.innerHTML = `${moveNumber}. <strong>${move.san}</strong> - ${quality.text}`;
                }
                
                moveList.appendChild(moveItem);
            });
            
            moveList.scrollTop = moveList.scrollHeight;
        }
    </script>
</body>
</html>